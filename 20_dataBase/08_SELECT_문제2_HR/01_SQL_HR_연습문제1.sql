/* ***** HR DB 데이터 조회 실습 *****************
■1 HR 부서에서 예산 편성 문제로 급여 정보 보고서를 작성하려고 한다. 
  사원정보(Employees) 테이블에서 급여가 $7,000~$10,000 범위 이외인 사람의 
  이름과 성(Name으로 별칭) 및 급여를 급여가 적은 순서로 출력하시오
*/
select first_name||' '||last_name Name, salary
 from employees 
where salary not between 7000 and 10000
order by salary
;
select first_name||' '||last_name Name, salary
 from employees 
where not (salary between 7000 and 10000)
order by salary
;
select first_name||' '||last_name Name, salary
 from employees
where salary <7000 or salary>10000
order by salary
;
/*
■2 HR 부서에서는 급여(salary)와 수당율(commission_pct)에 대한 지출 보고서를 작성하려고 한다. 
  수당을 받는 모든 사원의 이름과 성(Name으로 별칭), 급여, 업무, 수당율을 출력하시오. 
  이때 급여가 큰 순서대로 정렬하되, 급여가 같으면 수당율이 큰 순서대로 정렬하시오
*/
select * from employees; 
select employee_id, first_name||' '||last_name name, salary, job_id, commission_pct
  from employees 
 where commission_pct is not null
 order by salary desc , commission_pct desc
;
/*  
■3 이번 분기에 60번 IT 부서에서는 신규 프로그램을 개발하고 보급하여 회사에 공헌하였다. 
  이에 해당 부서의 사원 급여를 12.3% 인상하기로 하였다. 
  60번 IT 부서 사원의 급여를 12.3% 인상하여 정수만(반올림) 표시하는 보고서를 작성하시오. 
  보고서는 사원번호, 성과 이름(Name으로 별칭), 급여, 인상된 급여(Increase Salary로 별칭)순으로 출력하시오
*/  
select employee_id, first_name||' '||last_name name, salary,
        round(salary * 1.123) "Increase Salary",
        round(salary + (salary * 0.123)) " 이렇게도 가능 ",
        round(salary * 0.123) "인상된 급여"
  from employees
 where department_id = 60
;
/*
■4 각 사원의 성(last_name)이 's'로 끝나는 사원의 이름과 업무를 아래의 예와 같이 출력하고자 한다. 
  출력 시 이름(first_name)과 성(last_name)은 첫 글자가 대문자, 업무는 모두 대문자로 출력하고 
  머리글(조회컬럼명)은 Employee JOBs.로 표시하시오
  예) FIRST_NAME  LAST_NAME  Employee JOBs.
      Shelley     Higgins    AC_MGR
*/
select initcap(first_name) first_name, 
       initcap(last_name) last_name, 
       upper(job_id) "Employee JOBs."
  from employees
 where  lower(last_name) like '%s'
;
/*
■5 모든 사원의 연봉을 표시하는 보고서를 작성하려고 한다. 
  보고서에 사원의 이름과 성(Name으로 별칭), 급여, 수당여부에 따른 연봉을 포함하여 출력하시오. 
  수당여부는 수당이 있으면 "Salary + Commission", 수당이 없으면 "Salary only"라고 표시하고, 
  별칭은 적절히 붙이시오. 또한 출력 시 연봉이 높은 순으로 정렬하시오
*/
select employee_id,
       first_name||' '||last_name name, 
       salary, commission_pct,
       decode ( commission_pct , null, 'salary only','Salary+Commission')
       as commission_yn,
       salary*( 1 + nvl(commission_pct,0))*12 as salary12
  from employees 
 order by 6 desc
;
select commission_pct, nvl(commision_pct,0) from employees;

/*
■6 각 사원이 소속된 부서별로 급여 합계, 급여 평균, 급여 최댓값, 급여 최솟값을 집계하고자 한다. 
  계산된 출력값은 여섯 자리와 세 자리 구분기호, $표시와 함께 출력($123,456) 
  단, 부서에 소속되지 않은 사원에 대한 정보는 제외하고, 출력 시 머리글은 별칭(alias) 처리하시오
*/    
select department_id,
        to_char(sum(salary),'$999,999')sum_salary, 
        to_char(avg(salary),'$999,999')avg_salary,
        to_char(max(salary),'$999,999')max_salary,
        to_char(min(salary),'$999,999')min_salary
  from employees
 where department_id is not null
 group by department_id
;
/*
■7 사원들의 업무별 전체 급여 평균이 $10,000보다 큰 경우를 조회하여 
    업무별 급여 평균을 출력하시오. 
  단 업무에 CLERK이 포함된 경우는 제외하고 전체 급여 평균이 높은 순서대로 출력하시오
*/
--업무 (JOB_ID)에 CLERK이 포함된 업무확인 
select distinct job_id --distinct : 중복값 제거하고 하나만 표시
  from employees
 where upper(job_id) like upper('%clerk%')
;
select job_id
  from employees
 where upper(job_id) like upper('%clerk%')
 group by job_id
;
---------
select job_id,round(avg(salary)) avg_salary
 from employees 
where upper(job_id) not  like upper('%clerk%')
group by job_id
having round(avg(salary)) >  10000 -- alias못씀
order by avg_salary desc -- alias가능
;
/*
■8 HR 스키마에 존재하는 Employees, Departments, Locations 테이블의 구조를 파악한 후 
  Oxford에 근무하는 사원의 이름과 성(Name으로 별칭), 업무, 부서이름, 도시이름을 출력하시오. 
  이때 첫 번째 열은 회사이름인 'HR-Company'이라는 상수값이 출력되도록 하시오
*/
select 'HR-Company' as company_name,
       e.employee_id, e.first_name||' '||e.last_name name, 
       e.job_id, 
       d.department_name,
       l.city 
  from employees e
      inner join departments d on e.department_id = d.department_id
      inner join locations l on d.location_id = l.location_id
 where l.city = 'Oxford'--왠만하면 
 order by e.employee_id
;
select  'HR-Company' as company_name,
       e.employee_id, e.first_name||' '||e.last_name name, 
       e.job_id, 
       d.department_name,
       l.city 
  from employees e, departments d, locations l
 where e.department_id = d.department_id and d.location_id = l.location_id
   and l.city = 'Oxford'
 order by e.employee_id
;
--뷰가 이미 만들어져 있다 
--HR : emp_details_view 뷰(view)사용 
select  'HR-Company' as company_name,
       employee_id, first_name||' '||last_name name,
       job_id, 
       department_name,
       city 
  from emp_details_view 
 where city = 'Oxford'
 order by employee_id
;

/*
■9 HR 스키마에 있는 Employees, Departments 테이블의 구조를 파악한 후 
  사원수가 다섯 명 이상인 부서의 부서이름과 사원 수를 출력하시오. 
  이때 사원 수가 많은 순으로 정렬하시오
*/
--ansi
select e.department_id, d.department_name, count(*) emp_cnt
  from employees e inner join departments d on e.department_id = d.department_id
 group by e.department_id, d.department_name
having count(*) >= 5
order by 3 desc
;
--oracle
select d.department_name, count(*)
 from employees e , departments d
where e.department_id = d.department_id
group by d.department_name
having count(*) >= 5
order by count(*) desc
;
------부서별 인원을 구한뒤, 부서테이블 조인해서 부서명 확인 
select department_id, count(*) emp_cnt
  from employees
 group by department_id
;
select d.department_name, e.emp_cnt
  from (select department_id, count(*) emp_cnt
          from employees
         group by department_id) e,
         departments d
 where e.department_id = d.department_id
   and emp_cnt >= 5
 order by 2 desc
;
/*
■10 각 사원의 급여에 따른 급여 등급을 보고하려고 한다. 
  급여 등급은 Job_Grades 테이블에 표시된다. 해당 테이블의 구조를 살펴본 후 
  사원의 이름과 성(Name으로 별칭), 업무, 부서이름, 입사일, 급여, 급여등급을 출력하시오.
  
CREATE TABLE JOB_GRADES (
    GRADE_LEVEL VARCHAR2(3),
    LOWEST_SAL NUMBER,
    HIGHEST_SAL NUMBER
);
INSERT INTO JOB_GRADES VALUES ('A', 1000, 2999);
INSERT INTO JOB_GRADES VALUES ('B', 3000, 5999);
INSERT INTO JOB_GRADES VALUES ('C', 6000, 9999);
INSERT INTO JOB_GRADES VALUES ('D', 10000, 14999);
INSERT INTO JOB_GRADES VALUES ('E', 15000, 24999);
INSERT INTO JOB_GRADES VALUES ('F', 25000, 40000);
COMMIT;
********************************/
select * from job_grades
 where 6500 between lowest_sal and highest_sal;

--JOB_GRADE는 정의되지 않은 테이블이므로 동등조건이 없다 
select e.employee_id, e.first_name||' '||e.last_name name,
       e.job_id, d.department_name, e.hire_date, e.salary,
       J.grade_level
  from employees e, job_grades j,departments d 
 where e.department_id = d.department_id
   and e.salary between j.lowest_sal and j.highest_sal
 order by 1
;
--ansi
select e.employee_id, e.first_name||' '||e.last_name name,
       e.job_id, d.department_name, e.hire_date, e.salary,
       J.grade_level
  from employees e inner join departments d on e.department_id = d.department_id, 
       job_grades j
 where e.salary between j.lowest_sal and j.highest_sal
 order by 1
;


            
              

